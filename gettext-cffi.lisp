#|
cl-gettext - Common Lisp binding to GNU gettext
Copyright (C) 2011  Krzysztof Drewniak <krzysdrewniak <AT> gmail <DOT> com>

This library is free software; you can redistribute it and/or
modify it under the terms of the Lisp Lesser General Public
License, as published by the Free Software Foundation and Franz Inc.; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the Lisp
Lesser General Public License for more details.

You should have received a copy of the Lisp Lesser General Public
License along with this library (in the file COPYING); if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
|#

;;; This file was automatically generated by SWIG (http://www.swig.org).
;;; Version 1.3.40
;;;
;;; Do not make changes to this file unless you know what you are doing--modify
;;; the SWIG interface file instead.


;;;SWIG wrapper code starts here

(cl:in-package :cl-gettext)

(cl:defmacro defanonenum (&body enums)
   "Converts anonymous enums to defconstants."
  `(cl:progn ,@(cl:loop for value in enums
                        for index = 0 then (cl:1+ index)
                        when (cl:listp value) do (cl:setf index (cl:second value)
                                                          value (cl:first value))
                        collect `(cl:defconstant ,value ,index))))

(cl:eval-when (:compile-toplevel :load-toplevel)
  (cl:unless (cl:fboundp 'swig-lispify)
    (cl:defun swig-lispify (name flag cl:&optional (package cl:*package*))
      (cl:labels ((helper (lst last rest cl:&aux (c (cl:car lst)))
                    (cl:cond
                      ((cl:null lst)
                       rest)
                      ((cl:upper-case-p c)
                       (helper (cl:cdr lst) 'upper
                               (cl:case last
                                 ((lower digit) (cl:list* c #\- rest))
                                 (cl:t (cl:cons c rest)))))
                      ((cl:lower-case-p c)
                       (helper (cl:cdr lst) 'lower (cl:cons (cl:char-upcase c) rest)))
                      ((cl:digit-char-p c)
                       (helper (cl:cdr lst) 'digit 
                               (cl:case last
                                 ((upper lower) (cl:list* c #\- rest))
                                 (cl:t (cl:cons c rest)))))
                      ((cl:char-equal c #\_)
                       (helper (cl:cdr lst) '_ (cl:cons #\- rest)))
                      (cl:t
                       (cl:error "Invalid character: ~A" c)))))
        (cl:let ((fix (cl:case flag
                        ((constant enumvalue) "+")
                        (variable "*")
                        (cl:t ""))))
          (cl:intern
           (cl:concatenate
            'cl:string
            fix
            (cl:nreverse (helper (cl:concatenate 'cl:list name) cl:nil cl:nil))
            fix)
           package))))))

;;;SWIG wrapper code ends here


(cffi:defcfun ("gettext" gettext) :string
  "Get the translation (if any) of `__msgid', which is a string"
  (__msgid :string))

(cffi:defcfun ("dgettext" dgettext) :string
  "Like `gettext', except with explicit specification of the textdomain. You shouldn't use this, or any d* function, except in special circumstances, so they are not exported."
  (__domainname :string)
  (__msgid :string))

(cffi:defcfun ("dcgettext" dcgettext) :string
  "Like `dgettext', except also specifying the locale category. It's not exported for the same reason as `dgettext'."
  (__domainname :string)
  (__msgid :string)
  (__category :int))

(cffi:defcfun ("ngettext" %ngettext) :string
  (__msgid1 :string)
  (__msgid2 :string)
  (__n :unsigned-long))

(defun ngettext (msgid1 msgid2 n)
  "The plural version of `gettext' The first string should be the return value for n == 1, and the second string the value for n != 1. The third argument is n. Use this instead of an `if' because other languages have more or less than two branches for plurals, and this function allows translators to specify the plurals for their language."
  ;; Deals with plurals for long integers as recommended by Gettext manual, see
  ;; http://www.gnu.org/savannah-checkouts/gnu/gettext/manual/html_node/Plural-forms.html
  (%ngettext msgid1 msgid2 (if (> n 1000000)
                               (+ 1000000 (rem n 1000000))
                               n)))

(cffi:defcfun ("dngettext" %dngettext) :string
  (__domainname :string)
  (__msgid1 :string)
  (__msgid2 :string)
  (__n :unsigned-long))

(defun dngettext (domainname msgid1 msgid2 n)
  (%dngettext domainname msgid1 msgid2 (if (> n 1000000)
                                           (+ 1000000 (rem n 1000000))
                                           n)))

(cffi:defcfun ("textdomain" textdomain) :string
   "Set the textdomain for the application. The textdomain is the name (before the dot) of your project's .mo files"
  (__domainname :string))

(cffi:defcfun ("bindtextdomain" bindtextdomain) :string
   "Specify what directory the `textdomain' resides under. On Linux systems, this is usually \"/usr/share/locale\"."
  (__domainname :string)
  (__dirname :string))

(cffi:defcfun ("bind_textdomain_codeset" bind-textdomain-codeset) :string
  "Set the encoding for the strings stored in `__domain'. You normally don't need to call this, as the locale contains this information a;ready."
  (__domainname :string)
  (__codeset :string))

(defconstant LC-CTYPE 0 "A locale category.")
(defconstant LC-NUMERIC 1 "A locale category.")
(defconstant LC-TIME 2 "A locale category.")
(defconstant LC-COLLATE 3 "A locale category.")
(defconstant LC-MONETARY 4 "A locale category.")
(defconstant LC-MESSAGES 5 "A locale category.")
(defconstant LC-ALL 6 "A locale category. This category is the one which is most often used (and the default when initializing `cl-gettext')")
(defconstant LC-PAPER 7 "A locale category.")
(defconstant LC-NAME 8 "A locale category.")
(defconstant LC-ADDRESS 9 "A locale category.")
(defconstant LC-TELEPHONE 10 "A locale category.")
(defconstant LC-MEASUREMENT 11 "A locale category.")
(defconstant LC-IDENTIFICATION 12 "A locale category.")

(cffi:defcstruct lconv
        "Structure to hold locale information such as the number seperators."
	(decimal_point :string)
	(thousands_sep :string)
	(grouping :string)
	(int_curr_symbol :string)
	(currency_symbol :string)
	(mon_decimal_point :string)
	(mon_thousands_sep :string)
	(mon_grouping :string)
	(positive_sign :string)
	(negative_sign :string)
	(int_frac_digits :char)
	(frac_digits :char)
	(p_cs_precedes :char)
	(p_sep_by_space :char)
	(n_cs_precedes :char)
	(n_sep_by_space :char)
	(p_sign_posn :char)
	(n_sign_posn :char)
	(__int_p_cs_precedes :char)
	(__int_p_sep_by_space :char)
	(__int_n_cs_precedes :char)
	(__int_n_sep_by_space :char)
	(__int_p_sign_posn :char)
	(__int_n_sign_posn :char))

(cffi:defcfun ("setlocale" setlocale) :string
  "Set a locale category to the locale given in `__locale'. If __locale is \"\", the current system setting will be used."
  (__category :int)
  (__locale :string))

(cffi:defcfun ("localeconv" localeconv) :pointer
              "Returns an `lconv' structure with the information applicable for the current locale.")


